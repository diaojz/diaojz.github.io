<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刁爷的博客</title>
  
  <subtitle>从iOS奔向全栈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://diaojz.github.io/"/>
  <updated>2019-12-25T02:20:46.197Z</updated>
  <id>https://diaojz.github.io/</id>
  
  <author>
    <name>diaojz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构和算法之美</title>
    <link href="https://diaojz.github.io/2019/12/16/Reading/Reading-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89/"/>
    <id>https://diaojz.github.io/2019/12/16/Reading/Reading-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89/</id>
    <published>2019-12-16T12:39:54.000Z</published>
    <updated>2019-12-25T02:20:46.197Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录学习<code>数据结构和算法之美</code>专栏重要知识点。</p></blockquote><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(1)<br>O(n)<br>O(logn)<br>O(nlogn)<br>O(n^2)</p><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>额外的空间才算<br>例子：栈的空间是O(1)不是O(n)</p><a id="more"></a><h1 id="6-链表"><a href="#6-链表" class="headerlink" title="6. 链表"></a>6. 链表</h1><p>单链表：<br>循环链表： 约瑟夫环<br>双向链表： Java中的 LinkedHashMap就是<br>双向循环链表<br>空间换时间</p><h1 id="7-书写链表六个技巧"><a href="#7-书写链表六个技巧" class="headerlink" title="7. 书写链表六个技巧"></a>7. 书写链表六个技巧</h1><blockquote><p>链表的书写好坏，可以看出一个人，写代码是否细心，考虑问题是否全面，思维是否缜密。<br>所以作为面试题常见</p></blockquote><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ol><li>理解<code>指针</code>和<code>引用</code>， 警惕指针和内存泄露</li><li>哨兵：去除边界条件，简化</li><li>边界处理</li><li>举例画图</li><li>多写多练</li></ol><h2 id="练习题-LeetCode"><a href="#练习题-LeetCode" class="headerlink" title="练习题-LeetCode"></a>练习题-LeetCode</h2><ol><li>206 单链表反转</li><li>141 链表中环的检测</li><li>21  两个有序链表合并</li><li>19  删除链表倒数第N个节点</li><li>876 求链表中间节点</li></ol><h1 id="8-栈"><a href="#8-栈" class="headerlink" title="8. 栈"></a>8. 栈</h1><blockquote><p>操作受限的线性表<br>入栈<br>出栈</p></blockquote><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>数组：顺序栈<br>链表：链式栈</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(1)<br>空间：O(1)</p><h2 id="动态扩容-顺序栈"><a href="#动态扩容-顺序栈" class="headerlink" title="动态扩容==顺序栈=="></a>动态扩容==顺序栈==</h2><p>出栈：O(1)<br>入栈：O(n)  重新申请内存和数据搬移<br>均摊时间复杂度： O(1)   一般都等于最好的情况。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>函数调用:    临时变量</p></li><li><p>表达式求值：  2个栈，一个存数，一个存运算符</p></li><li><p>括号匹配：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用栈保存未匹配的左括号，依次从左开始扫描字符串。</span><br><span class="line">扫描到左括号，则入栈，</span><br><span class="line">当扫描到右括号，则从栈顶取一个左括号。</span><br><span class="line">如果匹配，比如（）、「」、『』，</span><br><span class="line">则继续扫描。</span><br><span class="line"><span class="number">1.</span>遇到不能配对的右括号</span><br><span class="line"><span class="number">2.</span>栈中没有数据</span><br><span class="line">则说明非法。</span><br><span class="line">如果栈为空，则字符串合法。</span><br></pre></td></tr></table></figure></li><li><p>浏览器历史记录  2个栈，一个存历史，一个存未来</p></li></ol><h1 id="9-队列"><a href="#9-队列" class="headerlink" title="9. 队列"></a>9. 队列</h1><blockquote><p>操作受限的线性表<br>入队<br>出队</p></blockquote><h2 id="种类-1"><a href="#种类-1" class="headerlink" title="种类"></a>种类</h2><p>数组：顺序队列<br>链表：链式队列</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(1)<br>空间：O(1)</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>循环队列：解决数据搬移问题</li><li>阻塞队列： 生产者-消费者模型</li><li>并发队列： 线程安全的队列</li></ol><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>线程池：<br>当没有空闲资源时，通过队列缓解<br>无界队列：基于链表实现的<br>有界队列：基于数组实现的，针对时间敏感的系统。<br>重点：合适的大小，太大会响应过慢，太小性能浪费</p><h1 id="10-递归"><a href="#10-递归" class="headerlink" title="10. 递归"></a>10. 递归</h1><blockquote><p>如何用三行代码，找到最终推荐人？</p></blockquote><h2 id="分3步"><a href="#分3步" class="headerlink" title="分3步"></a>分3步</h2><ol><li>可以分成几个子问题</li><li>问题和子问题，除了规模不同，求解思路完全一致</li><li>存在终止条件</li></ol><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>写出递归公式</li><li>找到终止条件</li></ol><h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><ol><li>DFS深度优先搜索</li><li>前中后序二叉树遍历<br>例子：3. 斐波那契数列<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> f(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>改进： 使用散列表存储中间值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> f(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasSovledList.<span class="keyword">get</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> ret = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">    hasSovledList.put(n, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>堆栈溢出<ol><li>提前预防，比如限制最大深度</li></ol></li><li>重复计算<ol><li>通过<code>散列表</code>之类的数据结构存储中间值</li></ol></li><li>空间复杂度，会积累。</li></ol><h2 id="递归改非递归"><a href="#递归改非递归" class="headerlink" title="递归改非递归"></a>递归改非递归</h2><p>改进  非递归方案</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> f(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> pre = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ret = pre + prepre;</span><br><span class="line">        prepre = pre;</span><br><span class="line">        pre = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试递归"><a href="#调试递归" class="headerlink" title="调试递归"></a>调试递归</h2><ol><li>打印日志发现，递归值</li><li>结合条件断点进行调试</li></ol><h1 id="11-排序"><a href="#11-排序" class="headerlink" title="11. 排序"></a>11. 排序</h1><blockquote><p>为啥<code>插入排序</code>比<code>冒泡排序</code>更受欢迎？</p></blockquote><h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><ol><li>冒泡排序</li></ol><ul><li><input checked disabled type="checkbox"> <ol start="2"><li>插入排序</li></ol></li></ul><ol start="3"><li>选择排序</li></ol><h2 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h2><ol start="4"><li>归并排序</li><li>快速排序</li></ol><h2 id="O-n-不基于比较"><a href="#O-n-不基于比较" class="headerlink" title="O(n), 不基于比较"></a>O(n), 不基于比较</h2><ol start="6"><li>计数排序</li><li>基数排序</li><li>桶排序</li></ol><h1 id="16-二分查找，快速定位IP对应的省份地址"><a href="#16-二分查找，快速定位IP对应的省份地址" class="headerlink" title="16. 二分查找，快速定位IP对应的省份地址"></a>16. 二分查找，快速定位IP对应的省份地址</h1><blockquote><p>普通二分查找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 二分查找(针对已经排好序的数组, 并且不能有重复值)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//找到中间下标</span></span><br><span class="line">        <span class="comment">//这种写法,有可能会溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//所以使用</span></span><br><span class="line"><span class="comment">//        int mid = low + ((high - low) &gt;&gt;1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">            <span class="comment">//找到目标</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            <span class="comment">//比目标小, 则从大区间接着找</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//比目标大, 则从小区间找</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有符合要求的</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变形1：查找第一个值等于给定的元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 查找第一个值等于给定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是第一个元素</span></span><br><span class="line">            <span class="comment">//或者与前一个元素值不等</span></span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) ||</span><br><span class="line">                (a[mid - <span class="number">1</span>] != value)) &#123;</span><br><span class="line">                <span class="comment">//就是要找的</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变形2：查找最后一个值等于给定的元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 查找最后一个值等于给定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是最后一个元素</span></span><br><span class="line">            <span class="comment">//或者与后一个元素和值不等</span></span><br><span class="line">            <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) ||</span><br><span class="line">                (a[mid + <span class="number">1</span>] != value)) &#123;</span><br><span class="line">                <span class="comment">//就是要找的</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变形3: 查找第一个大于给定值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 变形3: 查找第一个大于给定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">            <span class="comment">//如果是第一个元素</span></span><br><span class="line">            <span class="comment">//或者前面的元素比它小,则就是第一个大于它的值</span></span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) ||</span><br><span class="line">                (a[mid - <span class="number">1</span>] &lt; value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//小于,直接在大区间找</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变形4: 查找最后一个小于等于给定值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 变形4: 查找最后一个小于等于给定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是最后一个元素</span></span><br><span class="line">            <span class="comment">//或者后面的元素比它大,则就是最后一个小于等于的给定值</span></span><br><span class="line">            <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) ||</span><br><span class="line">                (a[mid + <span class="number">1</span>] &gt; value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-跳表（Redis）"><a href="#17-跳表（Redis）" class="headerlink" title="17. 跳表（Redis）"></a>17. 跳表（Redis）</h1><blockquote><p>链表加多级索引的结构，就是跳表<br>空间换时间<br>时间复杂度O(logn)<br>空间复杂度O(n)</p><p>插入操作时间复杂度O(logn), 链表的插入复杂度是O(1)，因为有序，所以需要先查找，即O(logn)<br>删除操作，也需要删除索引里面的</p></blockquote><h2 id="Redis核心操作"><a href="#Redis核心操作" class="headerlink" title="Redis核心操作"></a>Redis核心操作</h2><ol><li>插入一个数据</li><li>删除一个数据</li><li>查找一个数据</li><li>迭代输出有序序列</li><li>———-以上4条，红黑树也可以———–</li><li>按照区间查找数据（这个跳表效率更高）</li></ol><p>查找、插入、删除时间复杂度小 O(logn)<br>红黑树更复杂，不容易理解</p><h1 id="18-散列表"><a href="#18-散列表" class="headerlink" title="18. 散列表"></a>18. 散列表</h1><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><pre><code>1. md5、SHA、CRC等哈希算法</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h2><h2 id="散列冲突解决办法"><a href="#散列冲突解决办法" class="headerlink" title="散列冲突解决办法"></a>散列冲突解决办法</h2><ol><li>开放寻址法<ol><li>如果冲突，就再算一个</li><li>线性探测</li><li>二次探测</li><li>双重散列  </li></ol></li><li>链表法</li></ol><h2 id="工业级散列"><a href="#工业级散列" class="headerlink" title="工业级散列"></a>工业级散列</h2><ol><li>快速的查询、插入、删除操作</li><li>内存占用合理，不能占用过多内存</li><li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况</li></ol><p>设计方案</p><ol><li>设计合适的散列函数</li><li>定义装载因子阈值，设计动态扩容策略</li><li>选择合适的散列冲突解决方法</li></ol><h1 id="20-散列表为啥和链表一起使用"><a href="#20-散列表为啥和链表一起使用" class="headerlink" title="20. 散列表为啥和链表一起使用"></a>20. 散列表为啥和链表一起使用</h1><p>例子：LRU淘汰算法（最近最少使用）<br>一个节点,存四个值</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">prev</span> <span class="class"><span class="keyword">data</span> next hnext</span></span><br><span class="line">               存拉链</span><br></pre></td></tr></table></figure><p>则 O(1) 即可完成所有操作               </p><h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>通过双向链表和散列表组合</p><h2 id="为何要组合"><a href="#为何要组合" class="headerlink" title="为何要组合"></a>为何要组合</h2><p>因为散列表虽然高效，但是无序。<br>需要双向链表排序，方便增加、删除</p><h1 id="21-哈希算法的应用"><a href="#21-哈希算法的应用" class="headerlink" title="21. 哈希算法的应用"></a>21. 哈希算法的应用</h1><blockquote><p>鸽巢原理， 10个窝，11个鸟，必然有一个窝里有2只，所以就冲突了。</p></blockquote><ol><li>唯一标识符</li><li>校验数据完整性和正确性</li><li>安全加密， 会有散列冲突。主要在于权衡安全性和计算时间</li><li>散列函数， 更看中的是散列的平均性和执行效率</li></ol><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ol><li>MD5：  Message-Digest Algorithm.      MD5消息摘要算法</li><li>SHA：  Secure Hash Algorithm.         安全散列算法</li><li>DES：  Data Encryption Standard.      数据加密标准</li><li>AES：  Advanced Encryption Standard.  高级加密标准</li></ol><p>场景：脱库、彩虹表、加盐、区块链</p><h2 id="分布式中应用"><a href="#分布式中应用" class="headerlink" title="分布式中应用"></a>分布式中应用</h2><ol><li>负载均衡<ol><li>让同一台客户端，请求都由同一台服务器处理</li><li>哈希算法，对客户端IP地址进行计算，将取到的值与服务器列表大小取模运算，则都会到同一台服务器</li></ol></li><li>数据分片</li><li>分布式存储</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录学习&lt;code&gt;数据结构和算法之美&lt;/code&gt;专栏重要知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h1&gt;&lt;p&gt;O(1)&lt;br&gt;O(n)&lt;br&gt;O(logn)&lt;br&gt;O(nlogn)&lt;br&gt;O(n^2)&lt;/p&gt;
&lt;h1 id=&quot;空间复杂度&quot;&gt;&lt;a href=&quot;#空间复杂度&quot; class=&quot;headerlink&quot; title=&quot;空间复杂度&quot;&gt;&lt;/a&gt;空间复杂度&lt;/h1&gt;&lt;p&gt;额外的空间才算&lt;br&gt;例子：栈的空间是O(1)不是O(n)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美</title>
    <link href="https://diaojz.github.io/2019/12/03/Reading/Reading-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89/"/>
    <id>https://diaojz.github.io/2019/12/03/Reading/Reading-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89/</id>
    <published>2019-12-03T15:39:54.000Z</published>
    <updated>2019-12-25T02:20:43.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录学习<code>设计模式之美</code>专栏重要知识点。</p></blockquote><h1 id="1-业务开发基于贫血模式-MVC违背OOP吗？"><a href="#1-业务开发基于贫血模式-MVC违背OOP吗？" class="headerlink" title="1. 业务开发基于贫血模式 MVC违背OOP吗？"></a>1. 业务开发基于<code>贫血模式</code> MVC违背OOP吗？</h1><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>OOP四大特性：封装、继承、多态、抽象</li><li>接口</li><li>抽象类</li><li>面向过程风格</li><li>基于接口实现编程</li><li>多用组合少用继承</li></ol><h2 id="MVC（Model-View-Controller）"><a href="#MVC（Model-View-Controller）" class="headerlink" title="MVC（Model View Controller）"></a>MVC（Model View Controller）</h2><p>基于贫血模式， 被称为<code>反模式</code><br>展示层、逻辑层、数据层</p><h3 id="Web项目后端对应的设计模式（基于数据库开发）"><a href="#Web项目后端对应的设计模式（基于数据库开发）" class="headerlink" title="Web项目后端对应的设计模式（基于数据库开发）"></a>Web项目后端对应的设计模式（基于数据库开发）</h3><p>1.Respository层： 负责数据访问<br>2.Service层：     负责业务逻辑<br>3.Controller层：  负责暴露接口</p><a id="more"></a><h2 id="领域驱动设计（DDD）Domain-Driven-Design"><a href="#领域驱动设计（DDD）Domain-Driven-Design" class="headerlink" title="领域驱动设计（DDD）Domain Driven Design"></a>领域驱动设计（DDD）Domain Driven Design</h2><p>基于充血模式<br>2004年被提出，微服务加快了认知</p><h2 id="贫血模式（Anemic-Domain-Model）"><a href="#贫血模式（Anemic-Domain-Model）" class="headerlink" title="贫血模式（Anemic Domain Model）"></a>贫血模式（Anemic Domain Model）</h2><p>只包含数据，不包含业务逻辑的类，<br>基于SQL的CRUD操作。<br>平日一般都是基于SQL开发，先看接口需要查询什么数据，写完SQL查到数据，完善一下调用接口即可</p><h3 id="受欢迎原因"><a href="#受欢迎原因" class="headerlink" title="受欢迎原因:"></a>受欢迎原因:</h3><pre><code>1.大多时候，业务简单，用不着2.充血模式有难度，需要更多设计3.思维固化，转型有成本</code></pre><h2 id="充血模式（Rich-Domain-Model）"><a href="#充血模式（Rich-Domain-Model）" class="headerlink" title="充血模式（Rich Domain Model）"></a>充血模式（Rich Domain Model）</h2><p>数据和业务封装到同一个类中。典型的面向对象风格</p><h3 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h3><p>业务复杂的项目。业务调研，领域模型设计。 </p><h1 id="13-如何对接口鉴权这样一个功能开发做面向对象分析？-OOA"><a href="#13-如何对接口鉴权这样一个功能开发做面向对象分析？-OOA" class="headerlink" title="13.如何对接口鉴权这样一个功能开发做面向对象分析？(OOA)"></a>13.如何对接口鉴权这样一个功能开发做面向对象分析？(OOA)</h1><h2 id="面向对象分析（OOA）"><a href="#面向对象分析（OOA）" class="headerlink" title="面向对象分析（OOA）"></a>面向对象分析（OOA）</h2><p>产出：详细的需求描述</p><h1 id="14-如何利用面向对象设计和编程开发接口鉴权功能？-OOD、OOP"><a href="#14-如何利用面向对象设计和编程开发接口鉴权功能？-OOD、OOP" class="headerlink" title="14.如何利用面向对象设计和编程开发接口鉴权功能？(OOD、OOP)"></a>14.如何利用面向对象设计和编程开发接口鉴权功能？(OOD、OOP)</h1><h2 id="面向对象设计（OOD）"><a href="#面向对象设计（OOD）" class="headerlink" title="面向对象设计（OOD）"></a>面向对象设计（OOD）</h2><p>产出：类</p><ol><li>划分职责进⽽识别出有哪些类；<ol><li>罗列功能点，找相同属性</li><li>单一职责</li><li>模块划分，可缩小范围</li></ol></li><li>定义类及其属性和⽅法；<ol><li>动词：方法</li><li>名词：属性</li></ol></li><li>定义类与类之间的交互关系；<ol><li>泛化、实现、关联、聚合、组合、依赖 （UML中定义为6种）</li><li>做简化，保留4种。  泛化（继承）、实现、依赖、组合（组合、聚合、关联）</li></ol></li><li>将类组装起来并提供执⾏⼊⼝。<ol><li>统一封装，对外提供入口</li></ol></li></ol><h3 id="泛化（继承关系）-extends"><a href="#泛化（继承关系）-extends" class="headerlink" title="泛化（继承关系） extends"></a>泛化（继承关系） extends</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="实现（接口和实现关系）implements"><a href="#实现（接口和实现关系）implements" class="headerlink" title="实现（接口和实现关系）implements"></a>实现（接口和实现关系）implements</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="依赖（只要-B-类对象和-A-类对象有任何使用关系，我们都称它们有依赖关系）"><a href="#依赖（只要-B-类对象和-A-类对象有任何使用关系，我们都称它们有依赖关系）" class="headerlink" title="依赖（只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系）"></a>依赖（只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="keyword">new</span> B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(B b)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合（组合、聚合、关联）"><a href="#组合（组合、聚合、关联）" class="headerlink" title="组合（组合、聚合、关联）"></a>组合（组合、聚合、关联）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合，包含关系(鸟和翅膀)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="keyword">new</span> B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//聚合，包含关系（课程和学生）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关联，包含以上2种</span></span><br><span class="line">。。。</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><h2 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h2><h1 id="15-单一职责原则（SRP）"><a href="#15-单一职责原则（SRP）" class="headerlink" title="15.单一职责原则（SRP）"></a>15.单一职责原则（SRP）</h1><blockquote><p>Single Responsibility Principle<br>A class or module should have a single reponsibility.<br>一个类或模块只负责完成一个职责（功能）。</p></blockquote><p>不能脱离业务空谈。可以先做粒度粗的类，后面发展起来之后，再拆分更细的粒度。<code>持续重构</code></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ol><li>行数过多，影响可读和可维护</li><li>依赖过多其他类，不符合高内聚，低耦合</li><li>私有方法过多，应该独立到新类中，提供public方法，提高复用性</li><li>很难起名字，说明职责不清晰</li><li>集中在几个属性或方法中。例：在<code>UserInfo</code>中多数是操作<code>address</code>的话。</li></ol><h1 id="16-对扩展开放、修改关闭（OCP）"><a href="#16-对扩展开放、修改关闭（OCP）" class="headerlink" title="16.对扩展开放、修改关闭（OCP）"></a>16.对扩展开放、修改关闭（OCP）</h1><blockquote><p>Open Closed Principle<br>sofeware entities(modules,classes,functions,etc) should be open for extension, but closed for modification.<br>软件实体（模块、类、方法等）应该“对扩展开放，对修改关闭”</p></blockquote><blockquote><p>多数设计模式目标都是： 解决扩展性<br>比如如下几种：</p></blockquote><ol><li>多态</li><li>依赖注入</li><li>基于接口而非实现编程</li><li>装饰、策略、模板、职责链、状态</li></ol><h1 id="单继承、多实现"><a href="#单继承、多实现" class="headerlink" title="单继承、多实现"></a>单继承、多实现</h1><ul><li>interface   接口 </li><li>abstract    抽象类</li><li>extends     继承</li><li>implements  实现</li></ul><h1 id="17-里氏替换（LSP）跟多态有哪些区别？-哪些代码违背的LSP？"><a href="#17-里氏替换（LSP）跟多态有哪些区别？-哪些代码违背的LSP？" class="headerlink" title="17.里氏替换（LSP）跟多态有哪些区别？ 哪些代码违背的LSP？"></a>17.里氏替换（LSP）跟多态有哪些区别？ 哪些代码违背的LSP？</h1><blockquote><p>Liskov Substitution Principle<br>初衷：使用子类完美继承父类，并做了增强</p></blockquote><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>里式替换：设计原则<br>多态：是面向对象语法，是思路</p><h2 id="违背LSP原则"><a href="#违背LSP原则" class="headerlink" title="违背LSP原则"></a>违背LSP原则</h2><blockquote><p>原理：按照协议来设计  Design By Contract<br>子类和父类的关系：更像 接口和实现的关系。</p></blockquote><ol><li>子类违背父类  声明要实现的功能</li><li>子类违背父类  对输入、输出、异常的约定</li><li>子类违背父类  注释所罗列的任何特殊说明</li></ol><blockquote><p>检验方法： 拿父类的单元测试区验证子类，有不通过的，则说明有违背的地方</p></blockquote><h1 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h1><blockquote><p>Interface Segregation Principle</p></blockquote><h2 id="接口的类型："><a href="#接口的类型：" class="headerlink" title="接口的类型："></a>接口的类型：</h2><ol><li>一组接口集合<ol><li>如果只被部分使用，就应该隔离</li><li>不强迫调用者依赖不用的接口</li></ol></li><li>单个API或函数<ol><li>只需要部分功能，拆分更细粒度的函数</li></ol></li><li>OOP中的接口<ol><li>接口尽量单一，不要让<code>实现类</code>或<code>调用者</code>依赖不需要的接口</li><li>拆分为多个<code>协议</code></li></ol></li></ol><h2 id="与单一职责的区别"><a href="#与单一职责的区别" class="headerlink" title="与单一职责的区别"></a>与单一职责的区别</h2><ol><li>侧重<ol><li>单一职责侧重：模块、类、接口设计</li><li>接口隔离侧重：接口设计</li></ol></li><li>角度<ol><li>接口隔离提供间接判断单一职责标准</li><li>如果调用者只使用了部分功能，那接口的设计就不够职责单一</li></ol></li></ol><h1 id="19-控制反转（IOC）、依赖反转、依赖注入，这三者区别和联系"><a href="#19-控制反转（IOC）、依赖反转、依赖注入，这三者区别和联系" class="headerlink" title="19.控制反转（IOC）、依赖反转、依赖注入，这三者区别和联系"></a>19.控制反转（IOC）、依赖反转、依赖注入，这三者区别和联系</h1><blockquote><p>控制反转，是比较笼统的设计思想。<br>Inversion Of Control</p></blockquote><p>例子：模板设计模式、依赖注入。</p><h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><blockquote><p>是一种具体编码技巧。<br>Dependency Injection</p></blockquote><blockquote><p>不通过<code>New()</code>的方式在类<code>内部</code>创建依赖类对象，<br>而是将依赖的类对象在<code>外部</code>创建好之后，<br>通过<code>构造函数</code>、<code>函数参数</code>等方式传递或注入给类使用。</p></blockquote><h2 id="依赖注入框架（DI-Framework）"><a href="#依赖注入框架（DI-Framework）" class="headerlink" title="依赖注入框架（DI Framework）"></a>依赖注入框架（DI Framework）</h2><blockquote><p>把对象的创建、组装（注入）等工作，交给框架<br>Java Spring框架</p></blockquote><h2 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h2><blockquote><p>Dependency Inversion Principle<br>依赖倒置原则</p></blockquote><blockquote><p>High-level modules should’t depend on low-level modules.<br>Both modules should depend on abstractions.<br>In addition, abstractions should’t depend on details.<br>Detail depend on abstractions.</p></blockquote><blockquote><p>高层模块不依赖低层模块<br>所有模块通过抽象相互依赖<br>除此之外，抽象不要依赖实现<br>实现依赖抽象</p></blockquote><h1 id="20-KISS、-YAGNI原则"><a href="#20-KISS、-YAGNI原则" class="headerlink" title="20. KISS、 YAGNI原则"></a>20. KISS、 YAGNI原则</h1><blockquote><p>Keep it simple and stupid<br>Keep it short and simple<br>Keep it simple and straightforward</p><p>尽量保持简单</p></blockquote><ol><li>不要使用同时看不懂的技术实现</li><li>不同重复造轮子</li><li>不要过度优化</li></ol><h2 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h2><blockquote><p>You ain’t gonna need it<br>你不会需要它</p></blockquote><blockquote><p>不要设计当前用不到的功能，当前如果用不到就不要做。<br>但是该预留得预留。可扩展</p></blockquote><h1 id="21-提高代码复用性，DRY原则"><a href="#21-提高代码复用性，DRY原则" class="headerlink" title="21. 提高代码复用性，DRY原则"></a>21. 提高代码复用性，DRY原则</h1><blockquote><p>Don’t repeat yourself<br>不要重复自己</p></blockquote><h2 id="DRY原则"><a href="#DRY原则" class="headerlink" title="DRY原则"></a>DRY原则</h2><ol><li>实现逻辑重复</li><li>功能语义重复</li><li>代码执行重复</li></ol><h2 id="代码复用性"><a href="#代码复用性" class="headerlink" title="代码复用性"></a>代码复用性</h2><ol><li>减少代码耦合</li><li>满足单一职责</li><li>模块化</li><li>业务和非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ol><h1 id="22-迪米特法则（LOD）实现高内聚，低耦合"><a href="#22-迪米特法则（LOD）实现高内聚，低耦合" class="headerlink" title="22.迪米特法则（LOD）实现高内聚，低耦合"></a>22.迪米特法则（LOD）实现高内聚，低耦合</h1><h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><blockquote><p>指导类本身的设计<br>功能相近的应该放到同一个类中<br>不相关的功能，不放到同一类中</p></blockquote><h2 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h2><blockquote><p>指导类与类之间的设计<br>类和类之间的依赖关系清晰简单<br>一个类的修改，另一个应该不用或很少改动</p></blockquote><ol><li>依赖注入</li><li>接口隔离</li><li>基于接口而非实现编程</li><li>迪米特法则</li></ol><h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><blockquote><p>Law of Demeter</p><p>另一种叫法<br>The least knowledge principle<br>最小知识原则</p></blockquote><blockquote><p>Eash unit should have only limited knowledge about other units:<br>only units “closely” related to the current unit.<br>Or: Each unit should only talk to its friends;<br>Don’t talk to strangers.</p><p>每个模块应该只了解和它关系密切的模块<br>只和自己的朋友说话，不和陌生人说话</p></blockquote><ol><li>不该有直接依赖关系的类之间，不要有依赖</li><li>有依赖关系的类之间，尽量只依赖必要的接口（有限知识）</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>单一职责：自身出发<br>迪米特法则：关系出发<br>基于接口编程：使用者角度</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录学习&lt;code&gt;设计模式之美&lt;/code&gt;专栏重要知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-业务开发基于贫血模式-MVC违背OOP吗？&quot;&gt;&lt;a href=&quot;#1-业务开发基于贫血模式-MVC违背OOP吗？&quot; class=&quot;headerlink&quot; title=&quot;1. 业务开发基于贫血模式 MVC违背OOP吗？&quot;&gt;&lt;/a&gt;1. 业务开发基于&lt;code&gt;贫血模式&lt;/code&gt; MVC违背OOP吗？&lt;/h1&gt;&lt;h2 id=&quot;总结：&quot;&gt;&lt;a href=&quot;#总结：&quot; class=&quot;headerlink&quot; title=&quot;总结：&quot;&gt;&lt;/a&gt;总结：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;OOP四大特性：封装、继承、多态、抽象&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;抽象类&lt;/li&gt;
&lt;li&gt;面向过程风格&lt;/li&gt;
&lt;li&gt;基于接口实现编程&lt;/li&gt;
&lt;li&gt;多用组合少用继承&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;MVC（Model-View-Controller）&quot;&gt;&lt;a href=&quot;#MVC（Model-View-Controller）&quot; class=&quot;headerlink&quot; title=&quot;MVC（Model View Controller）&quot;&gt;&lt;/a&gt;MVC（Model View Controller）&lt;/h2&gt;&lt;p&gt;基于贫血模式， 被称为&lt;code&gt;反模式&lt;/code&gt;&lt;br&gt;展示层、逻辑层、数据层&lt;/p&gt;
&lt;h3 id=&quot;Web项目后端对应的设计模式（基于数据库开发）&quot;&gt;&lt;a href=&quot;#Web项目后端对应的设计模式（基于数据库开发）&quot; class=&quot;headerlink&quot; title=&quot;Web项目后端对应的设计模式（基于数据库开发）&quot;&gt;&lt;/a&gt;Web项目后端对应的设计模式（基于数据库开发）&lt;/h3&gt;&lt;p&gt;1.Respository层： 负责数据访问&lt;br&gt;2.Service层：     负责业务逻辑&lt;br&gt;3.Controller层：  负责暴露接口&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>后端技术38讲</title>
    <link href="https://diaojz.github.io/2019/11/29/Reading/Reading-%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF38%E8%AE%B2-%E6%9D%8E%E6%99%BA%E6%85%A7/"/>
    <id>https://diaojz.github.io/2019/11/29/Reading/Reading-%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF38%E8%AE%B2-%E6%9D%8E%E6%99%BA%E6%85%A7/</id>
    <published>2019-11-29T12:39:54.000Z</published>
    <updated>2019-12-25T02:29:30.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录学习<code>后端技术38讲</code>专栏重要知识点。</p></blockquote><h1 id="一、程序如何运行和如何崩溃"><a href="#一、程序如何运行和如何崩溃" class="headerlink" title="一、程序如何运行和如何崩溃"></a>一、程序如何运行和如何崩溃</h1><h2 id="1-如何运行"><a href="#1-如何运行" class="headerlink" title="1.如何运行"></a>1.如何运行</h2><blockquote><p>程序： 代码+算法<br>进程： 运行起来的程序</p></blockquote><pre><code>1.可执行代码2.堆内存控件3.栈内存控件4.进程数据结构</code></pre><blockquote><p>在申请<code>堆空间</code>，会把内存首地址，记录到<code>栈</code></p></blockquote><h2 id="同时运行多程序"><a href="#同时运行多程序" class="headerlink" title="同时运行多程序"></a>同时运行多程序</h2><p> 1.运行   数目小于CPU数目<br> 2.就绪   除CPU外，一切就绪<br> 3.阻塞   例如：等I/O,等待锁</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>为解决 <code>进程</code>在CPU上切换，代价大。使用更小的单位</p></blockquote><a id="more"></a><h2 id="系统变慢、崩溃"><a href="#系统变慢、崩溃" class="headerlink" title="系统变慢、崩溃"></a>系统变慢、崩溃</h2><blockquote><p>多任务处理</p></blockquote><blockquote><p>操作系统将硬件分时（CPU）分片（内存）管理，虚拟化成一个独享资源，让JVM进程在其上运行</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">物理服务器</span><br><span class="line">    操作系统</span><br><span class="line">        JVM进程</span><br><span class="line">            Tomcat容器</span><br><span class="line">                应用程序（war包）</span><br><span class="line">                多线程<span class="number">1</span></span><br><span class="line">                多线程<span class="number">2</span></span><br><span class="line">                。。。</span><br><span class="line">```                </span><br><span class="line"></span><br><span class="line">### 系统变慢</span><br><span class="line">每个`线程`有自己的`线程栈`，所以可以有相同变量。</span><br><span class="line">但同时操作`内存堆`，称为：`临界区`。涉及到`线程安全`，解决办法：`加锁`</span><br><span class="line">结果：会造成等待，系统变慢。</span><br><span class="line"></span><br><span class="line">### 系统崩溃</span><br><span class="line">被阻塞的线程，会占用资源。这些线程既不执行，也不释放。资源就会耗尽。</span><br><span class="line">结果：系统`宕机` </span><br><span class="line"></span><br><span class="line">### 解决方案</span><br><span class="line"><span class="number">1</span>.分布式系统架构</span><br><span class="line"><span class="number">2</span>.请求入口`限流`</span><br><span class="line"><span class="number">3</span>.在应用内进行业务`降级`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 二、数据结构原理</span><br><span class="line">&gt; Hash表的时间复杂度为什么是==O(<span class="number">1</span>)==？</span><br><span class="line"></span><br><span class="line">## 数组</span><br><span class="line">连续空间、相同数据</span><br><span class="line">通过下标+内存位置 = 元素位置  ==O(<span class="number">1</span>)==</span><br><span class="line">优点：查 时间复杂度==O(<span class="number">1</span>)==</span><br><span class="line"><span class="symbol">缺点:</span> 改 ==O(N)==</span><br><span class="line"></span><br><span class="line">## 链表</span><br><span class="line">不连续空间</span><br><span class="line">头指针 -&gt; data/next  -&gt; data/next -&gt; null</span><br><span class="line"><span class="symbol">优点:</span> 改 ==O(<span class="number">1</span>)==</span><br><span class="line">缺点：查 ==O(N)==</span><br><span class="line"></span><br><span class="line">## Hash表</span><br><span class="line">Key/Value  </span><br><span class="line">通过`Key`计算`HashCode`计算数组下标</span><br><span class="line">==余数法== ：使用Hash表的数组长度对HashCode求余，余数即为数组下标。</span><br></pre></td></tr></table></figure><p>例： key=”abc” value=”hello”<br>1.计算key的HashCode<br>    “abc”.hashcode = 101<br>2.计算HashCode对应的hash表索引<br>    101 % 8 = 5<br>3.则5就是下标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## hash冲突</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 解决方案是：`链表法`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 真实情况</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Hash表中的数组，要求存储`固定`长度数据。所以里面存储的是Key/Value元素的地址==指针==</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 冲突的元素，直接加到链表就行了</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 最坏的情况，全都冲突，则复杂度==O(N)==</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 栈</span></span></span><br><span class="line">对`数组`和`链表`加以限制，因为他们可以随意访问、修改</span><br><span class="line">后进先出</span><br><span class="line">有限制，安全简单。</span><br><span class="line">简单：是开发应该追求的目标。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 队列</span></span></span><br><span class="line">受限的线性表</span><br><span class="line">先进先出</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 树</span></span></span><br><span class="line">线性表：每个元素只有一个`前驱`和一个`后继`</span><br><span class="line">数是==非线性的==</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 思考题</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 如图：如何判断2个链表是否合并？如果合并，找到合并元素，即X元素。</span></span><br><span class="line">![](Reading-后端技术38讲-李智慧/15750190503495.png)</span><br></pre></td></tr></table></figure><p>答案：<br>计算2个链表的长度，谁长，谁先往前走。<br>待<code>长链表</code>未查看长度等于<code>短链表</code>时，<br>两两元素比较，<br>如果相等，则合并，此元素为X元素。<br>如果比较完，没有相等，则没有合并。</p><pre><code># 三、Java虚拟机原理&gt; java是一门跨平台语言。&gt; 可以运行在Windows、Linux等。&gt; 可在运行在X86、ARM架构的CPU上。&gt; 因为有JVM（Java Virtual Machine）## JVM的组成构造# 四、网络编程原理Tomcat: web容器管理网络通信Dubbo : 分布式服务框架完成网络通信## DNS&gt; IP协议： InternetProtocol  为方便编程，一般都用域名，DNS负责解析域名## CDN&gt; 内容分发网络 Content Delivery Network为提高访问速度,在运营商接入缓存服务器，缓存静态资源（图片、资源）&gt; 一般通过二级域名区分 例：image.taobao.com## 应用层 HTTP==应用层协议==  主要约定如何编码协议。### 请求头 HTTP请求头里包含了信息：GET/POST/DELETE/PUT/HEAD/TRACE等、缓存控制Cache-Control、响应过期时间Expires、Cookie等Post方法的还包含body部分，会在请求头里Content-Length里声明body长度。![](Reading-后端技术38讲-李智慧/15750299309589.png)### 响应头包含各种参数：状态码status、==200：成功====3XX：请求被重定向==302: 被临时重定向到新的URL==4XX: 客户端错误==403：请求为授权，被禁止访问404：请求页面不存在==5XX：服务器异常==500：请求为完成502：请求处理超时503：服务器过载### 响应体body：浏览器： HTMLApp: JSON ## 传输层 TCP==传输层协议==  建立稳定通信连接。为全球范围提供，所以统一应用层协议，使用==HTTP协议==socket编程## 网络层  IP协议IP协议不可靠。所以需要TCP三次握手头部添加IP地址## 数据链路层将数据封装：==数据帧== 以此为单位进行通信，此层定义帧的大小，称为==最大传输单元====帧头：== 发送者和接受者的mac地址,是网卡的设备标识符。唯一的## 物理层 处理不同设备、光纤、电缆等信号## OSI七层网络协议应用层：  应用层/表示层/会话层  TCP/IP协议将OSI顶部三层合并为一个应用层。 HTTP协议就是TCP/IP协议中的应用层协议。![](Reading-后端技术38讲-李智慧/15750304989573.png)## 总结每一层都添加一个头，不超过链路层最大传输单元的前提。每层协议在上一层基础上，添加一个头，最后封装成一个==数据帧==收到请求后，进行校验检查，准确后，删除头部信息。交给上一层协议处理。## LB（负责均衡）==Load balancing==解决高并发问题DNS解析出来的是LB的IP地址淘宝的解决方案：Linux内核的链路层负载均衡，也叫（直接路由模式）例：LB拿到数据包后，直接修改数据帧的mac地址，然后将数据重新发送给服务器集群所在的局域网。这个数据帧就会被真实的服务器收到。LB和真实的配置相同IP地址。所以响应的就直接发给App了，不经过LB。# 七、面向对象编程</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录学习&lt;code&gt;后端技术38讲&lt;/code&gt;专栏重要知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、程序如何运行和如何崩溃&quot;&gt;&lt;a href=&quot;#一、程序如何运行和如何崩溃&quot; class=&quot;headerlink&quot; title=&quot;一、程序如何运行和如何崩溃&quot;&gt;&lt;/a&gt;一、程序如何运行和如何崩溃&lt;/h1&gt;&lt;h2 id=&quot;1-如何运行&quot;&gt;&lt;a href=&quot;#1-如何运行&quot; class=&quot;headerlink&quot; title=&quot;1.如何运行&quot;&gt;&lt;/a&gt;1.如何运行&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;程序： 代码+算法&lt;br&gt;进程： 运行起来的程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1.可执行代码
2.堆内存控件
3.栈内存控件
4.进程数据结构&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;在申请&lt;code&gt;堆空间&lt;/code&gt;，会把内存首地址，记录到&lt;code&gt;栈&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;同时运行多程序&quot;&gt;&lt;a href=&quot;#同时运行多程序&quot; class=&quot;headerlink&quot; title=&quot;同时运行多程序&quot;&gt;&lt;/a&gt;同时运行多程序&lt;/h2&gt;&lt;p&gt; 1.运行   数目小于CPU数目&lt;br&gt; 2.就绪   除CPU外，一切就绪&lt;br&gt; 3.阻塞   例如：等I/O,等待锁&lt;/p&gt;
&lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;为解决 &lt;code&gt;进程&lt;/code&gt;在CPU上切换，代价大。使用更小的单位&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>从0开始学架构</title>
    <link href="https://diaojz.github.io/2019/09/29/Reading/Reading-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    <id>https://diaojz.github.io/2019/09/29/Reading/Reading-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/</id>
    <published>2019-09-29T12:39:54.000Z</published>
    <updated>2019-12-25T02:22:31.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录学习<code>从0开始学架构</code>专栏重要知识点。</p></blockquote><h1 id="27-如何设计计算高可用架构？"><a href="#27-如何设计计算高可用架构？" class="headerlink" title="27. 如何设计计算高可用架构？"></a>27. 如何设计计算高可用架构？</h1><h2 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h2><ol><li><p>冷备</p><ol><li>程序包和配置文件都准备好</li><li>==服务器是启动的==</li><li>主机故障后，人工将备份机的==业务系统启动==</li><li>将任务分配器的任务请求切换发给备机    </li></ol></li><li><p>温备</p><ol><li>==业务已经启动==</li><li>只是不对外提供服务</li><li>主机故障后，人工将任务分配器的任务请求发送给备机</li><li>推荐温备</li></ol></li></ol><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><blockquote><p>需要==任务分配器==对任务分类</p></blockquote><ol><li>主机  备机  分别计算</li><li>主机故障，任务继续发给主机，不管是否成功</li><li>如果主机恢复，任务继续分配给主机</li><li>如果主机不能恢复，将从机升级为主机（修改配置即可）。增加新的从机，从机就绪后，任务分配器继续分配。</li></ol><p>优点: 从机也发挥了性能<br>缺点：需要任务分类，增加复杂性</p><a id="more"></a><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><blockquote><p>（计算高可用）区别于（存储高可用）</p></blockquote><h3 id="对称集群（负载均衡集群）"><a href="#对称集群（负载均衡集群）" class="headerlink" title="对称集群（负载均衡集群）"></a>对称集群（负载均衡集群）</h3><ol><li>==任务分配器==采取策略，==随机、轮询等==分任务</li><li>某台故障，不再分配给它，分给其他</li><li>恢复后，再分给它</li></ol><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol><li>分配策略<ol><li>随机、轮询</li></ol></li><li>检测服务器状态<ol><li>是否宕机</li><li>网络是否正常</li><li>任务执行状态（卡死、响应慢）</li></ol></li></ol><p>常见做法：发送心跳包（服务器信息和任务信息）    </p><h3 id="非对称集群"><a href="#非对称集群" class="headerlink" title="非对称集群"></a>非对称集群</h3><blockquote><p>Master-Slave 这种的，有首领的</p></blockquote><ol><li>分角色。 ZAB算法选举、取ID最小做Master</li><li>分任务。 Master和Slave任务不同</li><li>故障。Master故障，需要选举一个Master；Slave故障，直接从集群里剔除</li></ol><p>复杂度增加</p><ol><li>任务分配策略。 划分任务类型</li><li>角色分配。 Master-Slave  通过ZAB、Raft方式选举Leader</li></ol><p>例：Zookeeper</p><ol><li>无任务分配器节点，每个Server都是任务分配器，Follower收到请求后进行判断，如果是==写==就发给Leader（Master）,如果是==读==就自己处理。</li><li>角色指定。 通过ZAB算法选举Leader，当Leader故障发生，所有Follower节点都==暂停读写操作==，开始选举，直到新Leader选出来。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录学习&lt;code&gt;从0开始学架构&lt;/code&gt;专栏重要知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;27-如何设计计算高可用架构？&quot;&gt;&lt;a href=&quot;#27-如何设计计算高可用架构？&quot; class=&quot;headerlink&quot; title=&quot;27. 如何设计计算高可用架构？&quot;&gt;&lt;/a&gt;27. 如何设计计算高可用架构？&lt;/h1&gt;&lt;h2 id=&quot;主备&quot;&gt;&lt;a href=&quot;#主备&quot; class=&quot;headerlink&quot; title=&quot;主备&quot;&gt;&lt;/a&gt;主备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;冷备&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序包和配置文件都准备好&lt;/li&gt;
&lt;li&gt;==服务器是启动的==&lt;/li&gt;
&lt;li&gt;主机故障后，人工将备份机的==业务系统启动==&lt;/li&gt;
&lt;li&gt;将任务分配器的任务请求切换发给备机    &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;温备&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;==业务已经启动==&lt;/li&gt;
&lt;li&gt;只是不对外提供服务&lt;/li&gt;
&lt;li&gt;主机故障后，人工将任务分配器的任务请求发送给备机&lt;/li&gt;
&lt;li&gt;推荐温备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;主从&quot;&gt;&lt;a href=&quot;#主从&quot; class=&quot;headerlink&quot; title=&quot;主从&quot;&gt;&lt;/a&gt;主从&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;需要==任务分配器==对任务分类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;主机  备机  分别计算&lt;/li&gt;
&lt;li&gt;主机故障，任务继续发给主机，不管是否成功&lt;/li&gt;
&lt;li&gt;如果主机恢复，任务继续分配给主机&lt;/li&gt;
&lt;li&gt;如果主机不能恢复，将从机升级为主机（修改配置即可）。增加新的从机，从机就绪后，任务分配器继续分配。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点: 从机也发挥了性能&lt;br&gt;缺点：需要任务分类，增加复杂性&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="https://diaojz.github.io/2019/09/18/Linux-learning/"/>
    <id>https://diaojz.github.io/2019/09/18/Linux-learning/</id>
    <published>2019-09-18T12:39:54.000Z</published>
    <updated>2019-12-25T02:25:25.737Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下常用的Linux命令。</p><h1 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h1><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下常用的Linux命令。&lt;/p&gt;
&lt;h1 id=&quot;服务管理&quot;&gt;&lt;a href=&quot;#服务管理&quot; class=&quot;headerlink&quot; title=&quot;服务管理&quot;&gt;&lt;/a&gt;服务管理&lt;/h1&gt;&lt;h2 id=&quot;防火墙&quot;&gt;&lt;a href=&quot;#防火墙&quot; class=&quot;headerlink&quot; title=&quot;防火墙&quot;&gt;&lt;/a&gt;防火墙&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://diaojz.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://diaojz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://diaojz.github.io/2019/08/23/Git-Cheat-Sheet/"/>
    <id>https://diaojz.github.io/2019/08/23/Git-Cheat-Sheet/</id>
    <published>2019-08-23T07:39:54.000Z</published>
    <updated>2019-12-25T02:25:23.953Z</updated>
    
    <content type="html"><![CDATA[<p>工作中使用最多的就是Git了，除了用了管理代码，发布博客。我还用来管理文档，可以使用<code>git show</code>或<code>git diff</code>查看更改。<br>整理了一下Git常用命令，方便随时查阅。</p><h1 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h1><p><img src="/2019/08/23/Git-Cheat-Sheet/git_command_pic.png" alt="Git常用命令速查表"></p><a id="more"></a><h1 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆远程版本库</span></span><br><span class="line">git clone &lt;url&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化本地版本库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="推送代码到指定仓库："><a href="#推送代码到指定仓库：" class="headerlink" title="推送代码到指定仓库："></a>推送代码到指定仓库：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送到主仓库</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送分支</span></span><br><span class="line">git push origin sit:sit   </span><br><span class="line">git push 仓库名  本地分支名:远程分支名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到gitee仓库(不同仓库)</span></span><br><span class="line">git push gitee master:master</span><br></pre></td></tr></table></figure><h2 id="查看本地代码关联的远程仓库"><a href="#查看本地代码关联的远程仓库" class="headerlink" title="查看本地代码关联的远程仓库"></a>查看本地代码关联的远程仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="解除远程git和本地代码绑定"><a href="#解除远程git和本地代码绑定" class="headerlink" title="解除远程git和本地代码绑定"></a>解除远程git和本地代码绑定</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对应的仓库名</span></span><br><span class="line">git remote rm gitee</span><br></pre></td></tr></table></figure><h1 id="修改、查看和提交"><a href="#修改、查看和提交" class="headerlink" title="修改、查看和提交"></a>修改、查看和提交</h1><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git mv &lt;old&gt; &lt;new&gt;</span><br><span class="line">git rm &lt;file&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件追踪</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 忽略追踪文件</span></span><br><span class="line">git rm -r --cached .</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看修改文件</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志详情</span></span><br><span class="line">git show</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看修改具体内容(工作区和暂存区差异)</span></span><br><span class="line">git diff</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定文件的提交历史记录</span></span><br><span class="line">git log -p &lt;file&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以列表的方式查看指定文件的提交历史</span></span><br><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git grep xxx</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "commit message"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改最后一次提交</span></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 撤销指定未提交的文件</span></span><br><span class="line">git checkout HEAD &lt;file&gt;</span><br><span class="line">git checkout xxx.xib  xxx.h  xxx.m</span><br></pre></td></tr></table></figure><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 撤销所有未提交的文件</span></span><br><span class="line">git reset --hard HEAD</span><br><span class="line"><span class="meta">#</span><span class="bash"> 撤销指定提交，是个相反的操作</span></span><br><span class="line">git revert &lt;commit号&gt;</span><br><span class="line">git revert 分支名 &lt;commit号&gt;</span><br><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5b0e5adc6fb9a009d82e4f20" target="_blank" rel="noopener">git revert 和 git reset区别</a></p><h1 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h1><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line">git merge &lt;branch即指定分支名&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 衍合</span></span><br><span class="line">git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过工具，解决合并冲突</span></span><br><span class="line">git mergetool -t opendiff</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并项目</span></span><br><span class="line">--allow-unrelated-histories</span><br></pre></td></tr></table></figure><h1 id="分支和标签"><a href="#分支和标签" class="headerlink" title="分支和标签"></a>分支和标签</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看分支（`-a`包含本地和远程所有分支）</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换分支/标签</span></span><br><span class="line">git checkout &lt;branch/tag&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建分支（`-b`会自动切换到当前分支）</span></span><br><span class="line">git checkout -b dev </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建指定分支(自动切换)</span></span><br><span class="line">git checkout -b 分支名 origin/远程分支名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建指定分支(不切换)</span></span><br><span class="line">git fetch origin 远程分支名x:本地分支名x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支(删除分支时,该分支必须完全和它的上游分支merge完成)</span></span><br><span class="line">git branch -d dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除分支(这样写可以在不检查merge状态的情况下删除分支)</span></span><br><span class="line">git branch -D dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除分支(将当前branch重置到初始点(startpoint),如果不使用--force的话,git分支无法修改一个已经存在的分支)</span></span><br><span class="line">git branch -d -f dev</span><br></pre></td></tr></table></figure><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看标签：</span></span><br><span class="line">git tag</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除标签 </span></span><br><span class="line">git tag -d v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打标签：</span></span><br><span class="line">git tag -a v1.0.0 -m 'version 1.0.0 打版'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示标签详情：</span></span><br><span class="line">git show v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送标签 </span></span><br><span class="line">git push origin v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送全部标签 </span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">打标签官网</a></p><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><h2 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.last log -l</span><br><span class="line">git config --global alias.gst git status</span><br><span class="line">git config --global alias.gc  git checkout</span><br><span class="line">git config --global alias.gcam git commit -a -m</span><br><span class="line">git config --global alias.br branch</span><br></pre></td></tr></table></figure><h2 id="丧心病狂的log"><a href="#丧心病狂的log" class="headerlink" title="丧心病狂的log"></a>丧心病狂的log</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><br></pre></td></tr></table></figure><h1 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h1><h2 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash pop</span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git stash pop [–index] [stash_id]</span><br><span class="line">git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。</span><br><span class="line">git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）</span><br><span class="line">git stash pop stash@&#123;1&#125;恢复指定的进度到工作区。stash_id是通过git stash list命令得到的 </span><br><span class="line">通过git stash pop命令恢复进度后，会删除当前进度。</span><br><span class="line"></span><br><span class="line">git stash apply [–index] [stash_id]</span><br><span class="line">除了不删除恢复的进度之外，其余和git stash pop 命令一样。</span><br><span class="line"></span><br><span class="line">git stash drop [stash_id]</span><br><span class="line">删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。</span><br><span class="line"></span><br><span class="line">git stash clear</span><br><span class="line">删除所有存储的进度。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中使用最多的就是Git了，除了用了管理代码，发布博客。我还用来管理文档，可以使用&lt;code&gt;git show&lt;/code&gt;或&lt;code&gt;git diff&lt;/code&gt;查看更改。&lt;br&gt;整理了一下Git常用命令，方便随时查阅。&lt;/p&gt;
&lt;h1 id=&quot;速查表&quot;&gt;&lt;a href=&quot;#速查表&quot; class=&quot;headerlink&quot; title=&quot;速查表&quot;&gt;&lt;/a&gt;速查表&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/23/Git-Cheat-Sheet/git_command_pic.png&quot; alt=&quot;Git常用命令速查表&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://diaojz.github.io/categories/CheatSheet/"/>
    
    
      <category term="Git" scheme="https://diaojz.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>程序员进阶攻略</title>
    <link href="https://diaojz.github.io/2019/08/21/Reading/Reading-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    <id>https://diaojz.github.io/2019/08/21/Reading/Reading-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/</id>
    <published>2019-08-21T12:59:53.000Z</published>
    <updated>2019-12-25T02:29:42.125Z</updated>
    
    <content type="html"><![CDATA[<!--# 程序员进阶攻略--><blockquote><p>最近在读程序员进阶攻略这本书，做点笔记，供自己回看。不断完善中。。。</p></blockquote><h2 id="05架构与实现：它们的连接与分界？"><a href="#05架构与实现：它们的连接与分界？" class="headerlink" title="05架构与实现：它们的连接与分界？"></a>05架构与实现：它们的连接与分界？</h2><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><blockquote><p>从建筑学来，在计算机工程中，架构师描述功能、组织和计算机系统实现的一组规则与方法。</p></blockquote><h3 id="共同认知"><a href="#共同认知" class="headerlink" title="共同认知"></a>共同认知</h3><blockquote><p>软件系统的结构与行为设计。</p><p>架构关注：==《熵》==建立《边界》和《要塞》<br>实现关注：==《简》==建立《领地》</p></blockquote><h3 id="纬度"><a href="#纬度" class="headerlink" title="纬度"></a>纬度</h3><ul><li>高维度：指系统、子系统或服务之间的切分与交互结构。</li><li>中维度：指系统、服务内部模块的切分与交互结构。</li><li>低维度：指模块组成的代码结构、数据结构、库表结构等。</li></ul><h3 id="架构师职责"><a href="#架构师职责" class="headerlink" title="架构师职责"></a>架构师职责</h3><ol><li>确定边界：划定问题域、系统域的边界。</li><li>切分协作：切分系统和服务，目的是建立分工与协作，并行以获得效率。</li><li>连接交互：在切分的各部分之间建立连接交互的原则和机制。</li><li>组装整合：把切分的各部分按预期定义的规则和方法组装整合为一体，完成系统目标。</li></ol><blockquote><p>你以为的架构师交付：一种架构（文档）文档只是载体。</p><p>实际上：==一整套决策流==，文档仅仅是交付载体（过程产物），最终体现在线上系统的运行结构中。</p></blockquote><a id="more"></a><h3 id="架构师需要考虑的方面"><a href="#架构师需要考虑的方面" class="headerlink" title="架构师需要考虑的方面"></a>架构师需要考虑的方面</h3><ol><li>选型评估</li><li>程序设计<ol><li>逻辑：即功能的业务逻辑，反映了真实业务场景流程与分支，包含大量业务领域知识。</li><li>控制：即考虑业务逻辑的执行策略，哪些可以并行执行，哪些可以异步执行，哪些地方又必须同步等待结果并串行执行？</li><li>数据：包括数据结构、数据状态变化和存取方式。</li></ol></li><li>执行效率</li><li>稳定健壮 </li><li>维护运维</li><li>集成部署</li></ol><p><img src="/2019/08/21/Reading/Reading-程序员进阶攻略/%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E6%96%B9%E9%9D%A2.jpg" alt="架构师需要考虑的方面"></p><h3 id="其他需要考虑"><a href="#其他需要考虑" class="headerlink" title="其他需要考虑"></a>其他需要考虑</h3><ol><li>你进一步要考虑代码的执行效率，需要运行多长时间？</li><li>要求的最大等待响应时间能否满足？</li><li>并发吞吐能力如何？</li><li>运行的稳定性和各种边界条件、异常处理是否考虑到了？</li><li>上线后，出现Bug，相关的监控、日志能否帮助快速定位？</li><li>是否有动态线上配置和变更能力，可以快速修复一些问题？</li><li>新上线版本时，你的程序是否考虑了兼容老版本的问题等？</li><li>最后你开发的代码是以什么形态交付？</li><li>如果是提供一个程序库，则需要考虑相关的依赖复杂度和使用便利性，以及未来的升级管理。</li><li>如果是提供服务，就需要考虑服务调用的管理、服务使用的统计监控，以及相关的SLA服务保障承诺。</li></ol><h3 id="断裂带"><a href="#断裂带" class="headerlink" title="断裂带"></a>断裂带</h3><blockquote><p>架构和实现之间的鸿沟。<br>因为决策是静态的，实现是动态的。</p></blockquote><p>解决方案：采用定期对系统状态做==快照==。<br>原则：关注战略性细节，只要没有越出==顶层宏观结构定义边界==即可。<br>桥梁：在鸿沟上建设，即==战略要地==。</p><blockquote><p>原因</p></blockquote><ol><li>沟通问题：如信息传递障碍。</li><li>水平问题：如技术能力不足。</li><li>态度问题：如偷懒走捷径。</li><li>现实问题：如无法变更的截止日期（Deadline）。</li></ol><h2 id="06模式与框架：它们的关系与误区？"><a href="#06模式与框架：它们的关系与误区？" class="headerlink" title="06模式与框架：它们的关系与误区？"></a>06模式与框架：它们的关系与误区？</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><blockquote><p>设计复用</p></blockquote><h3 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h3><blockquote><p>代码复用<br>越是通用的框架，意味着抽象度更高。而现实是越抽象，越难理解。</p></blockquote><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><blockquote><p>框架是程序代码，<br>模式是关于这些代码的知识。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>都是前人总结的经验</li><li>模式是代码层面，解决单个问题的成功方法。</li><li>框架是设计层面，解决一系列问题的成功方法。</li></ol><hr><h2 id="07多维与视图：系统设计的思考维度与展现视图"><a href="#07多维与视图：系统设计的思考维度与展现视图" class="headerlink" title="07多维与视图：系统设计的思考维度与展现视图"></a>07多维与视图：系统设计的思考维度与展现视图</h2><h3 id="语言UML"><a href="#语言UML" class="headerlink" title="语言UML"></a>语言UML</h3><h3 id="组成视图"><a href="#组成视图" class="headerlink" title="组成视图"></a>组成视图</h3><ol><li>子系统</li><li>服务</li><li>组件</li></ol><blockquote><p>划分原则</p></blockquote><ol><li>单一化：每个服务提供单一内聚的功能集。</li><li>正交化：任何一个功能仅由一个服务提供。没有类似功能的服务。</li></ol><p><img src="/2019/08/21/Reading/Reading-程序员进阶攻略/%E7%BB%84%E6%88%90%E8%A7%86%E5%9B%BE.jpg" alt="组成视图"></p><h3 id="交互视图"><a href="#交互视图" class="headerlink" title="交互视图"></a>交互视图</h3><blockquote><p>定义：与外部系统的协作关系，即依赖于被依赖。<br>重点:聚焦。<br>局部细节交互图</p></blockquote><p><img src="/2019/08/21/Reading/Reading-程序员进阶攻略/%E4%BA%A4%E4%BA%92%E8%A7%86%E5%9B%BE.jpg" alt="交互视图"></p><h3 id="部署视图"><a href="#部署视图" class="headerlink" title="部署视图"></a>部署视图</h3><blockquote><p>系统的部署结构和环境</p></blockquote><ol><li>主机环境</li><li>网络结构</li><li>环境元素依赖</li></ol><p><img src="/2019/08/21/Reading/Reading-程序员进阶攻略/%E9%83%A8%E7%BD%B2%E8%A7%86%E5%9B%BE.jpg" alt="部署视图"></p><p>上图:强调的是应用部署的IDC和网络的关系。关键的网络通讯延时指标。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>以上三类图（交互、组成、部署图）表达的是==宏观视图==<br>关注系统组合、协作和依存关系。</p></blockquote><h3 id="流程视图（UML中的序列图）"><a href="#流程视图（UML中的序列图）" class="headerlink" title="流程视图（UML中的序列图）"></a>流程视图（UML中的序列图）</h3><blockquote><p>表达系统内部实现的功能和控制逻辑流程。<br>业务和控制。</p></blockquote><p><img src="/2019/08/21/Reading/Reading-程序员进阶攻略/%E6%B5%81%E7%A8%8B%E8%A7%86%E5%9B%BE.jpg" alt="流程视图"></p><h3 id="状态视图"><a href="#状态视图" class="headerlink" title="状态视图"></a>状态视图</h3><blockquote><p>表达系统内部管理了哪些==状态==及状态的变迁==转移路径==。</p></blockquote><p><img src="/2019/08/21/Reading/Reading-程序员进阶攻略/%E7%8A%B6%E6%80%81%E8%A7%86%E5%9B%BE.jpg" alt="状态视图"></p>]]></content>
    
    <summary type="html">
    
      &lt;!--# 程序员进阶攻略--&gt;

&lt;blockquote&gt;
&lt;p&gt;最近在读程序员进阶攻略这本书，做点笔记，供自己回看。不断完善中。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;05架构与实现：它们的连接与分界？&quot;&gt;&lt;a href=&quot;#05架构与实现：它们的连接与分界？&quot; class=&quot;headerlink&quot; title=&quot;05架构与实现：它们的连接与分界？&quot;&gt;&lt;/a&gt;05架构与实现：它们的连接与分界？&lt;/h2&gt;&lt;h3 id=&quot;什么是架构&quot;&gt;&lt;a href=&quot;#什么是架构&quot; class=&quot;headerlink&quot; title=&quot;什么是架构&quot;&gt;&lt;/a&gt;什么是架构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从建筑学来，在计算机工程中，架构师描述功能、组织和计算机系统实现的一组规则与方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;共同认知&quot;&gt;&lt;a href=&quot;#共同认知&quot; class=&quot;headerlink&quot; title=&quot;共同认知&quot;&gt;&lt;/a&gt;共同认知&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;软件系统的结构与行为设计。&lt;/p&gt;
&lt;p&gt;架构关注：==《熵》==建立《边界》和《要塞》&lt;br&gt;实现关注：==《简》==建立《领地》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;纬度&quot;&gt;&lt;a href=&quot;#纬度&quot; class=&quot;headerlink&quot; title=&quot;纬度&quot;&gt;&lt;/a&gt;纬度&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;高维度：指系统、子系统或服务之间的切分与交互结构。&lt;/li&gt;
&lt;li&gt;中维度：指系统、服务内部模块的切分与交互结构。&lt;/li&gt;
&lt;li&gt;低维度：指模块组成的代码结构、数据结构、库表结构等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;架构师职责&quot;&gt;&lt;a href=&quot;#架构师职责&quot; class=&quot;headerlink&quot; title=&quot;架构师职责&quot;&gt;&lt;/a&gt;架构师职责&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;确定边界：划定问题域、系统域的边界。&lt;/li&gt;
&lt;li&gt;切分协作：切分系统和服务，目的是建立分工与协作，并行以获得效率。&lt;/li&gt;
&lt;li&gt;连接交互：在切分的各部分之间建立连接交互的原则和机制。&lt;/li&gt;
&lt;li&gt;组装整合：把切分的各部分按预期定义的规则和方法组装整合为一体，完成系统目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;你以为的架构师交付：一种架构（文档）文档只是载体。&lt;/p&gt;
&lt;p&gt;实际上：==一整套决策流==，文档仅仅是交付载体（过程产物），最终体现在线上系统的运行结构中。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://diaojz.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>使用markdown语法绘制甘特图</title>
    <link href="https://diaojz.github.io/2019/07/29/How-to-use-the-markdown-grammar-draw-a-gantt-chart/"/>
    <id>https://diaojz.github.io/2019/07/29/How-to-use-the-markdown-grammar-draw-a-gantt-chart/</id>
    <published>2019-07-29T06:56:03.000Z</published>
    <updated>2019-08-22T03:38:53.877Z</updated>
    
    <content type="html"><![CDATA[<!--# 甘特图--> <p>最近在项目中遇到需要绘制甘特图，使用了Excel绘制后，感觉并不顺手，不符合程序员的思维，于是搜索一番之后发现了更优雅的方式。</p><p>甘特图原理基本是一条线条图，横轴表示时间，纵轴表示活动(项目)，线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><a id="more"></a><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>首先打开在浏览器打开地址 <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown 编辑阅读器</a> 此编辑器支持绘制甘特图</p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>粘贴以下代码，修改项目中对应标题、日期、时间等。<br>具体语法很简单，看如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析        :a1, 2019-07-27, 5d</span><br><span class="line">    可行性报告      :after a1, 5d</span><br><span class="line">    概念验证        :5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计        :2019-08-05, 5d</span><br><span class="line">    详细设计        :2019-08-08, 10d</span><br><span class="line">    编码           :2019-08-15, 10d</span><br><span class="line">    测试           :2019-08-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p>语法编辑完成之后，右边会自动生成一张甘特图。<br>效果如下：<br><img src="/2019/07/29/How-to-use-the-markdown-grammar-draw-a-gantt-chart/gantt.jpg" alt="甘特图"></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>至此，一张漂亮的甘特图绘制完成。</p><h3 id="one-more"><a href="#one-more" class="headerlink" title="one more"></a>one more</h3><p> 除了有甘特图，此编辑器还可以绘制序列图、流程图、公式等，可以下载编辑器使用，支持全平台下载。<br> <a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">编辑器下载链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!--# 甘特图--&gt; 

&lt;p&gt;最近在项目中遇到需要绘制甘特图，使用了Excel绘制后，感觉并不顺手，不符合程序员的思维，于是搜索一番之后发现了更优雅的方式。&lt;/p&gt;
&lt;p&gt;甘特图原理基本是一条线条图，横轴表示时间，纵轴表示活动(项目)，线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://diaojz.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://diaojz.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何发布文章</title>
    <link href="https://diaojz.github.io/2019/07/29/hello-world/"/>
    <id>https://diaojz.github.io/2019/07/29/hello-world/</id>
    <published>2019-07-29T02:59:53.000Z</published>
    <updated>2019-12-25T02:26:34.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h2><blockquote><p>在hexo博客目录下，输入命令行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new "博客文章名字，最好是英文，方便生成链接路径"</span><br></pre></td></tr></table></figure><h2 id="本地运行服务，看效果"><a href="#本地运行服务，看效果" class="headerlink" title="本地运行服务，看效果"></a>本地运行服务，看效果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="一键发布到网站"><a href="#一键发布到网站" class="headerlink" title="一键发布到网站"></a>一键发布到网站</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清理 &amp;&amp; 生成静态文件 &amp;&amp; 部署远程网站</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>官网地址: <a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">官网中文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建一篇文章&quot;&gt;&lt;a href=&quot;#新建一篇文章&quot; class=&quot;headerlink&quot; title=&quot;新建一篇文章&quot;&gt;&lt;/a&gt;新建一篇文章&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在hexo博客目录下，输入命令行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figur
      
    
    </summary>
    
    
      <category term="教程" scheme="https://diaojz.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://diaojz.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
