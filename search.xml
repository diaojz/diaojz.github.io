<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构和算法之美]]></title>
    <url>%2F2019%2F12%2F16%2FReading%2FReading-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89%2F</url>
    <content type="text"><![CDATA[记录学习数据结构和算法之美专栏重要知识点。 时间复杂度O(1)O(n)O(logn)O(nlogn)O(n^2) 空间复杂度额外的空间才算例子：栈的空间是O(1)不是O(n) 6. 链表单链表：循环链表： 约瑟夫环双向链表： Java中的 LinkedHashMap就是双向循环链表空间换时间 7. 书写链表六个技巧 链表的书写好坏，可以看出一个人，写代码是否细心，考虑问题是否全面，思维是否缜密。所以作为面试题常见 技巧 理解指针和引用， 警惕指针和内存泄露 哨兵：去除边界条件，简化 边界处理 举例画图 多写多练 练习题-LeetCode 206 单链表反转 141 链表中环的检测 21 两个有序链表合并 19 删除链表倒数第N个节点 876 求链表中间节点 8. 栈 操作受限的线性表入栈出栈 种类数组：顺序栈链表：链式栈 复杂度时间：O(1)空间：O(1) 动态扩容==顺序栈==出栈：O(1)入栈：O(n) 重新申请内存和数据搬移均摊时间复杂度： O(1) 一般都等于最好的情况。 应用 函数调用: 临时变量 表达式求值： 2个栈，一个存数，一个存运算符 括号匹配： 123456789用栈保存未匹配的左括号，依次从左开始扫描字符串。扫描到左括号，则入栈，当扫描到右括号，则从栈顶取一个左括号。如果匹配，比如（）、「」、『』，则继续扫描。1.遇到不能配对的右括号2.栈中没有数据则说明非法。如果栈为空，则字符串合法。 浏览器历史记录 2个栈，一个存历史，一个存未来 9. 队列 操作受限的线性表入队出队 种类数组：顺序队列链表：链式队列 复杂度时间：O(1)空间：O(1) 扩展 循环队列：解决数据搬移问题 阻塞队列： 生产者-消费者模型 并发队列： 线程安全的队列 应用线程池：当没有空闲资源时，通过队列缓解无界队列：基于链表实现的有界队列：基于数组实现的，针对时间敏感的系统。重点：合适的大小，太大会响应过慢，太小性能浪费 10. 递归 如何用三行代码，找到最终推荐人？ 分3步 可以分成几个子问题 问题和子问题，除了规模不同，求解思路完全一致 存在终止条件 解题思路 写出递归公式 找到终止条件 应用 DFS深度优先搜索 前中后序二叉树遍历例子：3. 斐波那契数列12345int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return f(n-1) + f(n-2);&#125; 改进： 使用散列表存储中间值 1234567891011int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; if (hasSolvedList.containsKey(n)) &#123; return hasSovledList.get(n); &#125; int ret = f(n-1) + f(n-2); hasSovledList.put(n, ret); return ret;&#125; 问题 堆栈溢出 提前预防，比如限制最大深度 重复计算 通过散列表之类的数据结构存储中间值 空间复杂度，会积累。 递归改非递归改进 非递归方案 1234567891011121314int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; int ret = 0; int pre = 2; int prepre = 1; for (int i = 3; i &lt;= n; ++i) &#123; ret = pre + prepre; prepre = pre; pre = ret; &#125; return ret;&#125; 调试递归 打印日志发现，递归值 结合条件断点进行调试 11. 排序 为啥插入排序比冒泡排序更受欢迎？ O(n^2) 冒泡排序 插入排序 选择排序 O(nlogn) 归并排序 快速排序 O(n), 不基于比较 计数排序 基数排序 桶排序 16. 二分查找，快速定位IP对应的省份地址 普通二分查找 12345678910111213141516171819202122232425262728/// 二分查找(针对已经排好序的数组, 并且不能有重复值)public int bsearch(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; while (low &lt; high) &#123; //找到中间下标 //这种写法,有可能会溢出 int mid = (low + high) / 2; //所以使用// int mid = low + ((high - low) &gt;&gt;1); if (a[mid] == value) &#123; //找到目标 return mid; &#125; else if (a[mid] &lt; value) &#123; //比目标小, 则从大区间接着找 low = mid + 1; &#125; else &#123; //比目标大, 则从小区间找 high = mid - 1; &#125; &#125; //没有符合要求的 return -1;&#125; 变形1：查找第一个值等于给定的元素 1234567891011121314151617181920212223242526/// 查找第一个值等于给定值public int bsearch(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (a[mid] &gt; value) &#123; high = mid - 1; &#125; else if (a[mid] &lt; value) &#123; low = mid + 1; &#125; else &#123; //如果是第一个元素 //或者与前一个元素值不等 if ((mid == 0) || (a[mid - 1] != value)) &#123; //就是要找的 return mid; &#125; else &#123; high = mid - 1; &#125; &#125; &#125; return -1;&#125; 变形2：查找最后一个值等于给定的元素 1234567891011121314151617181920212223242526/// 查找最后一个值等于给定值public int bsearch(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (a[mid] &gt; value) &#123; high = mid - 1; &#125; else if (a[mid] &lt; value) &#123; low = mid + 1; &#125; else &#123; //如果是最后一个元素 //或者与后一个元素和值不等 if ((mid == n - 1) || (a[mid + 1] != value)) &#123; //就是要找的 return mid; &#125; else &#123; high = mid + 1; &#125; &#125; &#125; return -1;&#125; 变形3: 查找第一个大于给定值 12345678910111213141516171819202122232425/// 变形3: 查找第一个大于给定值public int bsearch3(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (a[mid] &gt;= value) &#123; //如果是第一个元素 //或者前面的元素比它小,则就是第一个大于它的值 if ((mid == 0) || (a[mid - 1] &lt; value)) &#123; return mid; &#125; else &#123; high = mid - 1; &#125; &#125; else &#123; //小于,直接在大区间找 low = mid + 1; &#125; &#125; return -1;&#125; 变形4: 查找最后一个小于等于给定值 123456789101112131415161718192021222324/// 变形4: 查找最后一个小于等于给定值public int bsearch3(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (a[mid] &gt; value) &#123; high = mid - 1; &#125; else &#123; //如果是最后一个元素 //或者后面的元素比它大,则就是最后一个小于等于的给定值 if ((mid == n - 1) || (a[mid + 1] &gt; value)) &#123; return mid; &#125; else &#123; low = mid + 1; &#125; &#125; &#125; return -1;&#125; 17. 跳表（Redis） 链表加多级索引的结构，就是跳表空间换时间时间复杂度O(logn)空间复杂度O(n) 插入操作时间复杂度O(logn), 链表的插入复杂度是O(1)，因为有序，所以需要先查找，即O(logn)删除操作，也需要删除索引里面的 Redis核心操作 插入一个数据 删除一个数据 查找一个数据 迭代输出有序序列 ———-以上4条，红黑树也可以———– 按照区间查找数据（这个跳表效率更高） 查找、插入、删除时间复杂度小 O(logn)红黑树更复杂，不容易理解 18. 散列表散列函数1. md5、SHA、CRC等哈希算法1234int hash(Object key) &#123; int h = key.hashCode(); return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1);&#125; 装载因子散列冲突解决办法 开放寻址法 如果冲突，就再算一个 线性探测 二次探测 双重散列 链表法 工业级散列 快速的查询、插入、删除操作 内存占用合理，不能占用过多内存 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况 设计方案 设计合适的散列函数 定义装载因子阈值，设计动态扩容策略 选择合适的散列冲突解决方法 20. 散列表为啥和链表一起使用例子：LRU淘汰算法（最近最少使用）一个节点,存四个值 12prev data next hnext 存拉链 则 O(1) 即可完成所有操作 Redis有序集合Java LinkedHashMap通过双向链表和散列表组合 为何要组合因为散列表虽然高效，但是无序。需要双向链表排序，方便增加、删除 21. 哈希算法的应用 鸽巢原理， 10个窝，11个鸟，必然有一个窝里有2只，所以就冲突了。 唯一标识符 校验数据完整性和正确性 安全加密， 会有散列冲突。主要在于权衡安全性和计算时间 散列函数， 更看中的是散列的平均性和执行效率 加密算法 MD5： Message-Digest Algorithm. MD5消息摘要算法 SHA： Secure Hash Algorithm. 安全散列算法 DES： Data Encryption Standard. 数据加密标准 AES： Advanced Encryption Standard. 高级加密标准 场景：脱库、彩虹表、加盐、区块链 分布式中应用 负载均衡 让同一台客户端，请求都由同一台服务器处理 哈希算法，对客户端IP地址进行计算，将取到的值与服务器列表大小取模运算，则都会到同一台服务器 数据分片 分布式存储]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之美]]></title>
    <url>%2F2019%2F12%2F03%2FReading%2FReading-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89%2F</url>
    <content type="text"><![CDATA[记录学习设计模式之美专栏重要知识点。 1. 业务开发基于贫血模式 MVC违背OOP吗？总结： OOP四大特性：封装、继承、多态、抽象 接口 抽象类 面向过程风格 基于接口实现编程 多用组合少用继承 MVC（Model View Controller）基于贫血模式， 被称为反模式展示层、逻辑层、数据层 Web项目后端对应的设计模式（基于数据库开发）1.Respository层： 负责数据访问2.Service层： 负责业务逻辑3.Controller层： 负责暴露接口 领域驱动设计（DDD）Domain Driven Design基于充血模式2004年被提出，微服务加快了认知 贫血模式（Anemic Domain Model）只包含数据，不包含业务逻辑的类，基于SQL的CRUD操作。平日一般都是基于SQL开发，先看接口需要查询什么数据，写完SQL查到数据，完善一下调用接口即可 受欢迎原因:1.大多时候，业务简单，用不着 2.充血模式有难度，需要更多设计 3.思维固化，转型有成本充血模式（Rich Domain Model）数据和业务封装到同一个类中。典型的面向对象风格 什么时候使用业务复杂的项目。业务调研，领域模型设计。 13.如何对接口鉴权这样一个功能开发做面向对象分析？(OOA)面向对象分析（OOA）产出：详细的需求描述 14.如何利用面向对象设计和编程开发接口鉴权功能？(OOD、OOP)面向对象设计（OOD）产出：类 划分职责进⽽识别出有哪些类； 罗列功能点，找相同属性 单一职责 模块划分，可缩小范围 定义类及其属性和⽅法； 动词：方法 名词：属性 定义类与类之间的交互关系； 泛化、实现、关联、聚合、组合、依赖 （UML中定义为6种） 做简化，保留4种。 泛化（继承）、实现、依赖、组合（组合、聚合、关联） 将类组装起来并提供执⾏⼊⼝。 统一封装，对外提供入口 泛化（继承关系） extends12public class A &#123; ... &#125;public class B extends A &#123; ... &#125; 实现（接口和实现关系）implements12public interface A &#123;...&#125;public class B implements A &#123; ... &#125; 依赖（只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系）1234567891011121314151617public class A &#123; private B b; public A(B b) &#123; this.b = b; &#125;&#125;//或者public class A &#123; private B b; public A() &#123; this.b = new B(); &#125;&#125;//或者public class A &#123; public void func(B b) &#123; ... &#125;&#125; 组合（组合、聚合、关联）12345678910111213141516171819//组合，包含关系(鸟和翅膀)public class A &#123; private B b; public A() &#123; this.b = new B(); &#125;&#125;//聚合，包含关系（课程和学生）public class A &#123; private B b; public A(B b) &#123; this.b = b; &#125;&#125;//关联，包含以上2种。。。。。。 面向对象编程（OOP）15.单一职责原则（SRP） Single Responsibility PrincipleA class or module should have a single reponsibility.一个类或模块只负责完成一个职责（功能）。 不能脱离业务空谈。可以先做粒度粗的类，后面发展起来之后，再拆分更细的粒度。持续重构 技巧 行数过多，影响可读和可维护 依赖过多其他类，不符合高内聚，低耦合 私有方法过多，应该独立到新类中，提供public方法，提高复用性 很难起名字，说明职责不清晰 集中在几个属性或方法中。例：在UserInfo中多数是操作address的话。 16.对扩展开放、修改关闭（OCP） Open Closed Principlesofeware entities(modules,classes,functions,etc) should be open for extension, but closed for modification.软件实体（模块、类、方法等）应该“对扩展开放，对修改关闭” 多数设计模式目标都是： 解决扩展性比如如下几种： 多态 依赖注入 基于接口而非实现编程 装饰、策略、模板、职责链、状态 单继承、多实现 interface 接口 abstract 抽象类 extends 继承 implements 实现 17.里氏替换（LSP）跟多态有哪些区别？ 哪些代码违背的LSP？ Liskov Substitution Principle初衷：使用子类完美继承父类，并做了增强 区别里式替换：设计原则多态：是面向对象语法，是思路 违背LSP原则 原理：按照协议来设计 Design By Contract子类和父类的关系：更像 接口和实现的关系。 子类违背父类 声明要实现的功能 子类违背父类 对输入、输出、异常的约定 子类违背父类 注释所罗列的任何特殊说明 检验方法： 拿父类的单元测试区验证子类，有不通过的，则说明有违背的地方 接口隔离原则（ISP） Interface Segregation Principle 接口的类型： 一组接口集合 如果只被部分使用，就应该隔离 不强迫调用者依赖不用的接口 单个API或函数 只需要部分功能，拆分更细粒度的函数 OOP中的接口 接口尽量单一，不要让实现类或调用者依赖不需要的接口 拆分为多个协议 与单一职责的区别 侧重 单一职责侧重：模块、类、接口设计 接口隔离侧重：接口设计 角度 接口隔离提供间接判断单一职责标准 如果调用者只使用了部分功能，那接口的设计就不够职责单一 19.控制反转（IOC）、依赖反转、依赖注入，这三者区别和联系 控制反转，是比较笼统的设计思想。Inversion Of Control 例子：模板设计模式、依赖注入。 依赖注入（DI） 是一种具体编码技巧。Dependency Injection 不通过New()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递或注入给类使用。 依赖注入框架（DI Framework） 把对象的创建、组装（注入）等工作，交给框架Java Spring框架 依赖反转原则（DIP） Dependency Inversion Principle依赖倒置原则 High-level modules should’t depend on low-level modules.Both modules should depend on abstractions.In addition, abstractions should’t depend on details.Detail depend on abstractions. 高层模块不依赖低层模块所有模块通过抽象相互依赖除此之外，抽象不要依赖实现实现依赖抽象 20. KISS、 YAGNI原则 Keep it simple and stupidKeep it short and simpleKeep it simple and straightforward 尽量保持简单 不要使用同时看不懂的技术实现 不同重复造轮子 不要过度优化 YAGNI原则 You ain’t gonna need it你不会需要它 不要设计当前用不到的功能，当前如果用不到就不要做。但是该预留得预留。可扩展 21. 提高代码复用性，DRY原则 Don’t repeat yourself不要重复自己 DRY原则 实现逻辑重复 功能语义重复 代码执行重复 代码复用性 减少代码耦合 满足单一职责 模块化 业务和非业务逻辑分离 通用代码下沉 继承、多态、抽象、封装 应用模板等设计模式 22.迪米特法则（LOD）实现高内聚，低耦合高内聚 指导类本身的设计功能相近的应该放到同一个类中不相关的功能，不放到同一类中 松耦合 指导类与类之间的设计类和类之间的依赖关系清晰简单一个类的修改，另一个应该不用或很少改动 依赖注入 接口隔离 基于接口而非实现编程 迪米特法则 迪米特法则（LOD） Law of Demeter 另一种叫法The least knowledge principle最小知识原则 Eash unit should have only limited knowledge about other units:only units “closely” related to the current unit.Or: Each unit should only talk to its friends;Don’t talk to strangers. 每个模块应该只了解和它关系密切的模块只和自己的朋友说话，不和陌生人说话 不该有直接依赖关系的类之间，不要有依赖 有依赖关系的类之间，尽量只依赖必要的接口（有限知识） 思考单一职责：自身出发迪米特法则：关系出发基于接口编程：使用者角度]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端技术38讲]]></title>
    <url>%2F2019%2F11%2F29%2FReading%2FReading-%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF38%E8%AE%B2-%E6%9D%8E%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[记录学习后端技术38讲专栏重要知识点。 一、程序如何运行和如何崩溃1.如何运行 程序： 代码+算法进程： 运行起来的程序 1.可执行代码 2.堆内存控件 3.栈内存控件 4.进程数据结构 在申请堆空间，会把内存首地址，记录到栈 同时运行多程序 1.运行 数目小于CPU数目 2.就绪 除CPU外，一切就绪 3.阻塞 例如：等I/O,等待锁 线程 为解决 进程在CPU上切换，代价大。使用更小的单位 系统变慢、崩溃 多任务处理 操作系统将硬件分时（CPU）分片（内存）管理，虚拟化成一个独享资源，让JVM进程在其上运行 1234567891011121314151617181920212223242526272829303132333435363738394041424344物理服务器 操作系统 JVM进程 Tomcat容器 应用程序（war包） 多线程1 多线程2 。。。``` ### 系统变慢每个`线程`有自己的`线程栈`，所以可以有相同变量。但同时操作`内存堆`，称为：`临界区`。涉及到`线程安全`，解决办法：`加锁`结果：会造成等待，系统变慢。### 系统崩溃被阻塞的线程，会占用资源。这些线程既不执行，也不释放。资源就会耗尽。结果：系统`宕机` ### 解决方案1.分布式系统架构2.请求入口`限流`3.在应用内进行业务`降级`# 二、数据结构原理&gt; Hash表的时间复杂度为什么是==O(1)==？## 数组连续空间、相同数据通过下标+内存位置 = 元素位置 ==O(1)==优点：查 时间复杂度==O(1)==缺点: 改 ==O(N)==## 链表不连续空间头指针 -&gt; data/next -&gt; data/next -&gt; null优点: 改 ==O(1)==缺点：查 ==O(N)==## Hash表Key/Value 通过`Key`计算`HashCode`计算数组下标==余数法== ：使用Hash表的数组长度对HashCode求余，余数即为数组下标。 例： key=”abc” value=”hello”1.计算key的HashCode “abc”.hashcode = 1012.计算HashCode对应的hash表索引 101 % 8 = 53.则5就是下标 12345678910111213141516171819202122232425### hash冲突&gt; 解决方案是：`链表法`### 真实情况&gt; Hash表中的数组，要求存储`固定`长度数据。所以里面存储的是Key/Value元素的地址==指针==&gt; 冲突的元素，直接加到链表就行了&gt; 最坏的情况，全都冲突，则复杂度==O(N)==## 栈对`数组`和`链表`加以限制，因为他们可以随意访问、修改后进先出有限制，安全简单。简单：是开发应该追求的目标。## 队列受限的线性表先进先出## 树线性表：每个元素只有一个`前驱`和一个`后继`数是==非线性的==## 思考题&gt; 如图：如何判断2个链表是否合并？如果合并，找到合并元素，即X元素。![](Reading-后端技术38讲-李智慧/15750190503495.png) 答案：计算2个链表的长度，谁长，谁先往前走。待长链表未查看长度等于短链表时，两两元素比较，如果相等，则合并，此元素为X元素。如果比较完，没有相等，则没有合并。 # 三、Java虚拟机原理 &gt; java是一门跨平台语言。 &gt; 可以运行在Windows、Linux等。 &gt; 可在运行在X86、ARM架构的CPU上。 &gt; 因为有JVM（Java Virtual Machine） ## JVM的组成构造 # 四、网络编程原理 Tomcat: web容器管理网络通信 Dubbo : 分布式服务框架完成网络通信 ## DNS &gt; IP协议： InternetProtocol 为方便编程，一般都用域名，DNS负责解析域名 ## CDN &gt; 内容分发网络 Content Delivery Network 为提高访问速度,在运营商接入缓存服务器，缓存静态资源（图片、资源） &gt; 一般通过二级域名区分 例：image.taobao.com ## 应用层 HTTP ==应用层协议== 主要约定如何编码协议。 ### 请求头 HTTP请求头里包含了信息：GET/POST/DELETE/PUT/HEAD/TRACE等、缓存控制Cache-Control、响应过期时间Expires、Cookie等 Post方法的还包含body部分，会在请求头里Content-Length里声明body长度。 ![](Reading-后端技术38讲-李智慧/15750299309589.png) ### 响应头 包含各种参数：状态码status、 ==200：成功== ==3XX：请求被重定向== 302: 被临时重定向到新的URL ==4XX: 客户端错误== 403：请求为授权，被禁止访问 404：请求页面不存在 ==5XX：服务器异常== 500：请求为完成 502：请求处理超时 503：服务器过载 ### 响应体 body： 浏览器： HTML App: JSON ## 传输层 TCP ==传输层协议== 建立稳定通信连接。 为全球范围提供，所以统一应用层协议，使用==HTTP协议== socket编程 ## 网络层 IP协议 IP协议不可靠。所以需要TCP三次握手 头部添加IP地址 ## 数据链路层 将数据封装：==数据帧== 以此为单位进行通信，此层定义帧的大小，称为==最大传输单元== ==帧头：== 发送者和接受者的mac地址,是网卡的设备标识符。唯一的 ## 物理层 处理不同设备、光纤、电缆等信号 ## OSI七层网络协议 应用层： 应用层/表示层/会话层 TCP/IP协议将OSI顶部三层合并为一个应用层。 HTTP协议就是TCP/IP协议中的应用层协议。 ![](Reading-后端技术38讲-李智慧/15750304989573.png) ## 总结 每一层都添加一个头，不超过链路层最大传输单元的前提。 每层协议在上一层基础上，添加一个头，最后封装成一个==数据帧== 收到请求后，进行校验检查，准确后，删除头部信息。交给上一层协议处理。 ## LB（负责均衡） ==Load balancing== 解决高并发问题 DNS解析出来的是LB的IP地址 淘宝的解决方案：Linux内核的链路层负载均衡，也叫（直接路由模式） 例：LB拿到数据包后，直接修改数据帧的mac地址，然后将数据重新发送给服务器集群所在的局域网。 这个数据帧就会被真实的服务器收到。 LB和真实的配置相同IP地址。所以响应的就直接发给App了，不经过LB。 # 七、面向对象编程]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始学架构]]></title>
    <url>%2F2019%2F09%2F29%2FReading%2FReading-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[记录学习从0开始学架构专栏重要知识点。 27. 如何设计计算高可用架构？主备 冷备 程序包和配置文件都准备好 ==服务器是启动的== 主机故障后，人工将备份机的==业务系统启动== 将任务分配器的任务请求切换发给备机 温备 ==业务已经启动== 只是不对外提供服务 主机故障后，人工将任务分配器的任务请求发送给备机 推荐温备 主从 需要==任务分配器==对任务分类 主机 备机 分别计算 主机故障，任务继续发给主机，不管是否成功 如果主机恢复，任务继续分配给主机 如果主机不能恢复，将从机升级为主机（修改配置即可）。增加新的从机，从机就绪后，任务分配器继续分配。 优点: 从机也发挥了性能缺点：需要任务分类，增加复杂性 集群 （计算高可用）区别于（存储高可用） 对称集群（负载均衡集群） ==任务分配器==采取策略，==随机、轮询等==分任务 某台故障，不再分配给它，分给其他 恢复后，再分给它 关键点 分配策略 随机、轮询 检测服务器状态 是否宕机 网络是否正常 任务执行状态（卡死、响应慢） 常见做法：发送心跳包（服务器信息和任务信息） 非对称集群 Master-Slave 这种的，有首领的 分角色。 ZAB算法选举、取ID最小做Master 分任务。 Master和Slave任务不同 故障。Master故障，需要选举一个Master；Slave故障，直接从集群里剔除 复杂度增加 任务分配策略。 划分任务类型 角色分配。 Master-Slave 通过ZAB、Raft方式选举Leader 例：Zookeeper 无任务分配器节点，每个Server都是任务分配器，Follower收到请求后进行判断，如果是==写==就发给Leader（Master）,如果是==读==就自己处理。 角色指定。 通过ZAB算法选举Leader，当Leader故障发生，所有Follower节点都==暂停读写操作==，开始选举，直到新Leader选出来。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2019%2F09%2F18%2FLinux-learning%2F</url>
    <content type="text"><![CDATA[记录一下常用的Linux命令。 服务管理防火墙]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2019%2F08%2F23%2FGit-Cheat-Sheet%2F</url>
    <content type="text"><![CDATA[工作中使用最多的就是Git了，除了用了管理代码，发布博客。我还用来管理文档，可以使用git show或git diff查看更改。整理了一下Git常用命令，方便随时查阅。 速查表 版本库创建版本库1234# 克隆远程版本库git clone &lt;url&gt;# 初始化本地版本库git init 推送代码到指定仓库：12345678# 推送到主仓库git push origin master# 推送分支git push origin sit:sit git push 仓库名 本地分支名:远程分支名# 推送到gitee仓库(不同仓库)git push gitee master:master 查看本地代码关联的远程仓库1git remote -v 解除远程git和本地代码绑定123git remote rm origin# 对应的仓库名git remote rm gitee 修改、查看和提交修改12345678git add .git add &lt;file&gt;git mv &lt;old&gt; &lt;new&gt;git rm &lt;file&gt;# 删除文件追踪git rm --cached &lt;file&gt;# 忽略追踪文件git rm -r --cached . 查看123456789101112# 查看修改文件git status# 查看日志详情git show# 查看修改具体内容(工作区和暂存区差异)git diff# 查看日志git log# 查看指定文件的提交历史记录git log -p &lt;file&gt;# 以列表的方式查看指定文件的提交历史git blame &lt;file&gt; 搜索1git grep xxx 提交123git commit -m "commit message"# 修改最后一次提交git commit --amend 撤销123# 撤销指定未提交的文件git checkout HEAD &lt;file&gt;git checkout xxx.xib xxx.h xxx.m 回滚123456# 撤销所有未提交的文件git reset --hard HEAD# 撤销指定提交，是个相反的操作git revert &lt;commit号&gt;git revert 分支名 &lt;commit号&gt;git revert HEAD^ git revert 和 git reset区别 代码合并合并1234# 合并指定分支到当前分支git merge &lt;branch即指定分支名&gt;# 衍合git rebase &lt;branch&gt; 解决冲突1234# 通过工具，解决合并冲突git mergetool -t opendiff# 合并项目--allow-unrelated-histories 分支和标签分支12345678910111213141516# 查看分支（`-a`包含本地和远程所有分支）git branch -a# 切换分支/标签git checkout &lt;branch/tag&gt;# 创建分支（`-b`会自动切换到当前分支）git checkout -b dev # 创建指定分支(自动切换)git checkout -b 分支名 origin/远程分支名# 创建指定分支(不切换)git fetch origin 远程分支名x:本地分支名x# 删除分支(删除分支时,该分支必须完全和它的上游分支merge完成)git branch -d dev# 强制删除分支(这样写可以在不检查merge状态的情况下删除分支)git branch -D dev# 强制删除分支(将当前branch重置到初始点(startpoint),如果不使用--force的话,git分支无法修改一个已经存在的分支)git branch -d -f dev 打标签123456789101112# 查看标签：git tag# 删除标签 git tag -d v1.0.0# 打标签：git tag -a v1.0.0 -m 'version 1.0.0 打版'# 显示标签详情：git show v1.0.0# 推送标签 git push origin v1.0.0# 推送全部标签 git push origin --tags 打标签官网 别名打开配置文件12vim ~/.bash_profilesource ~/.bash_profile 配置别名12345git config --global alias.last log -lgit config --global alias.gst git statusgit config --global alias.gc git checkoutgit config --global alias.gcam git commit -a -mgit config --global alias.br branch 丧心病狂的log1git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 暂存普通用法123git stashgit stash popgit stash list 高级用法1234567891011121314git stash pop [–index] [stash_id]git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）git stash pop stash@&#123;1&#125;恢复指定的进度到工作区。stash_id是通过git stash list命令得到的 通过git stash pop命令恢复进度后，会删除当前进度。git stash apply [–index] [stash_id]除了不删除恢复的进度之外，其余和git stash pop 命令一样。git stash drop [stash_id]删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。git stash clear删除所有存储的进度。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员进阶攻略]]></title>
    <url>%2F2019%2F08%2F21%2FReading%2FReading-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[最近在读程序员进阶攻略这本书，做点笔记，供自己回看。不断完善中。。。 05架构与实现：它们的连接与分界？什么是架构 从建筑学来，在计算机工程中，架构师描述功能、组织和计算机系统实现的一组规则与方法。 共同认知 软件系统的结构与行为设计。 架构关注：==《熵》==建立《边界》和《要塞》实现关注：==《简》==建立《领地》 纬度 高维度：指系统、子系统或服务之间的切分与交互结构。 中维度：指系统、服务内部模块的切分与交互结构。 低维度：指模块组成的代码结构、数据结构、库表结构等。 架构师职责 确定边界：划定问题域、系统域的边界。 切分协作：切分系统和服务，目的是建立分工与协作，并行以获得效率。 连接交互：在切分的各部分之间建立连接交互的原则和机制。 组装整合：把切分的各部分按预期定义的规则和方法组装整合为一体，完成系统目标。 你以为的架构师交付：一种架构（文档）文档只是载体。 实际上：==一整套决策流==，文档仅仅是交付载体（过程产物），最终体现在线上系统的运行结构中。 架构师需要考虑的方面 选型评估 程序设计 逻辑：即功能的业务逻辑，反映了真实业务场景流程与分支，包含大量业务领域知识。 控制：即考虑业务逻辑的执行策略，哪些可以并行执行，哪些可以异步执行，哪些地方又必须同步等待结果并串行执行？ 数据：包括数据结构、数据状态变化和存取方式。 执行效率 稳定健壮 维护运维 集成部署 其他需要考虑 你进一步要考虑代码的执行效率，需要运行多长时间？ 要求的最大等待响应时间能否满足？ 并发吞吐能力如何？ 运行的稳定性和各种边界条件、异常处理是否考虑到了？ 上线后，出现Bug，相关的监控、日志能否帮助快速定位？ 是否有动态线上配置和变更能力，可以快速修复一些问题？ 新上线版本时，你的程序是否考虑了兼容老版本的问题等？ 最后你开发的代码是以什么形态交付？ 如果是提供一个程序库，则需要考虑相关的依赖复杂度和使用便利性，以及未来的升级管理。 如果是提供服务，就需要考虑服务调用的管理、服务使用的统计监控，以及相关的SLA服务保障承诺。 断裂带 架构和实现之间的鸿沟。因为决策是静态的，实现是动态的。 解决方案：采用定期对系统状态做==快照==。原则：关注战略性细节，只要没有越出==顶层宏观结构定义边界==即可。桥梁：在鸿沟上建设，即==战略要地==。 原因 沟通问题：如信息传递障碍。 水平问题：如技术能力不足。 态度问题：如偷懒走捷径。 现实问题：如无法变更的截止日期（Deadline）。 06模式与框架：它们的关系与误区？设计模式 设计复用 开发框架 代码复用越是通用的框架，意味着抽象度更高。而现实是越抽象，越难理解。 关系 框架是程序代码，模式是关于这些代码的知识。 总结 都是前人总结的经验 模式是代码层面，解决单个问题的成功方法。 框架是设计层面，解决一系列问题的成功方法。 07多维与视图：系统设计的思考维度与展现视图语言UML组成视图 子系统 服务 组件 划分原则 单一化：每个服务提供单一内聚的功能集。 正交化：任何一个功能仅由一个服务提供。没有类似功能的服务。 交互视图 定义：与外部系统的协作关系，即依赖于被依赖。重点:聚焦。局部细节交互图 部署视图 系统的部署结构和环境 主机环境 网络结构 环境元素依赖 上图:强调的是应用部署的IDC和网络的关系。关键的网络通讯延时指标。 总结 以上三类图（交互、组成、部署图）表达的是==宏观视图==关注系统组合、协作和依存关系。 流程视图（UML中的序列图） 表达系统内部实现的功能和控制逻辑流程。业务和控制。 状态视图 表达系统内部管理了哪些==状态==及状态的变迁==转移路径==。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用markdown语法绘制甘特图]]></title>
    <url>%2F2019%2F07%2F29%2FHow-to-use-the-markdown-grammar-draw-a-gantt-chart%2F</url>
    <content type="text"><![CDATA[最近在项目中遇到需要绘制甘特图，使用了Excel绘制后，感觉并不顺手，不符合程序员的思维，于是搜索一番之后发现了更优雅的方式。 甘特图原理基本是一条线条图，横轴表示时间，纵轴表示活动(项目)，线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 步骤一首先打开在浏览器打开地址 Cmd Markdown 编辑阅读器 此编辑器支持绘制甘特图 步骤二粘贴以下代码，修改项目中对应标题、日期、时间等。具体语法很简单，看如下示例： 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2019-07-27, 5d 可行性报告 :after a1, 5d 概念验证 :5dsection 项目实施 概要设计 :2019-08-05, 5d 详细设计 :2019-08-08, 10d 编码 :2019-08-15, 10d 测试 :2019-08-22, 5dsection 发布验收 发布: 2d 验收: 3d 步骤三语法编辑完成之后，右边会自动生成一张甘特图。效果如下： 结束至此，一张漂亮的甘特图绘制完成。 one more 除了有甘特图，此编辑器还可以绘制序列图、流程图、公式等，可以下载编辑器使用，支持全平台下载。 编辑器下载链接]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何发布文章]]></title>
    <url>%2F2019%2F07%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[新建一篇文章 在hexo博客目录下，输入命令行 1hexo new "博客文章名字，最好是英文，方便生成链接路径" 本地运行服务，看效果123hexo server# 或者hexo s 一键发布到网站1234# 清理 &amp;&amp; 生成静态文件 &amp;&amp; 部署远程网站hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy# 或者hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 官网地址: 官网中文]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
